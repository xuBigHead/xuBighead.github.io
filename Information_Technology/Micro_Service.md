# 微服务

## 设计原则

### 单一职责

每个微服务只应担负一个职责。大量的代码耦合，会带来和单体架构一样的问题，维护难、测试难、部署难 ……



### 高内聚

关系紧密的行为应放在一起。



### 低耦合

一个服务的变更不要影响其他服务。



#### 隐藏内部实现

不同业务的逻辑应在内部实现并提供结果给其它服务，避免直接暴露内部实现，防止误操作和造成不必要的耦合关系。



#### 避免代码库共享

共享代码的确非常方便，但是会造成底层代码关联度太强。

对于以后的升级非常不便，例如某个服务想把语言版本升级，但共享库使用的是低版本，其中某些用法在高版本中是过期的，这就很尴尬了。

例如**不共享**，各服务重新造轮子，这样服务之间就有边界了。这个方式只适用于需要共享的库是非常稳定的，不怎么需要改了，否则的话相关服务都需要改。

再比如把共享库的**粒度缩小**，避免形成功能特别全的大库。大库必然导致被引用的范围非常广，影响面大。如果粒度很小的话，涉及的服务也就少。



#### 避免数据过度暴露

过度暴露会增加服务间的耦合度。



#### 避免数据库共享

一个服务想获取另一个服务的数据时，只应该通过接口，而不是直接从对方的数据库中拿。



#### 最小化同步调用

同步调用会产生网络的阻塞，对被调用服务的可用性要求极高，所以要慎重使用。



#### 最小化硬件共享

服务设计得很好，但如果硬件部署没有规划好，一样非常痛苦。

例如两个服务部署在一台服务器上，服务B 非常消耗资源，那么服务A可能就没法用了。所以，不能忽略硬件这个关键点，要根据各个服务的特点做好均衡部署。



#### 避免使用平台独特性技术

例如 Java RMI 做远程调用不错，但它是平台特性，要求服务双方都用一套技术，这种高耦合就不如平台独立的 REST 更自由了。



### 高度自治

- 独立部署运行和扩展

	- 每个服务能够独立被部署并运行在一个进程内
	- 这种运行和部署方式能够赋予系统灵活的代码组织方式和发布节奏，使得快速交付和应对变化成为可能。

- 独立开发和演进

	- 技术选型灵活，不受遗留系统技术栈的约束。
	- 合适的业务问题可以选择合适的技术栈，可以独立的演进
	- 服务与服务之间采取与语言无关的API进行集成

- 独立的团队和自治

	- 团队对服务的整个生命周期负责，工作在独立的上下文中， 谁开发，谁维护。

	

### 以业务为中心

- 每个服务代表了特定的业务逻辑
- 有明显的边界上下文
- 围绕业务组织团队
- 能快速的响应业务的变化
- 隔离实现细节，让业务领域可以被重用



### 弹性设计

- 设计可容错的系统

	- 拥抱失败，为已知的错误而设计
	- 依赖的服务挂掉
	- 网络连接问题

- 设计具有自我保护能力的系统

	- 服务隔离
	- 服务降级
	- 限制使用资源
	- 防止级联错误

	

### 日志和监控

当产品环境出错时，需要快速的定位问题，检测可能发生的意外和故障。而日志与监控是快速定位和预防的不二选择，在微服务架构中更是至关重要。

- 高度可观察，我们需要对正在发生的事情有一个整体的视角。
- 聚合你的日志，聚合你的数据，从而当你遇到问题时，可以深入分析原因。
- 当需要重现令人讨厌的问题，或仅仅查看你的系统在生产环境如何交互时，`关联标识`可以帮助你跟踪系统间的调用。

监控主要包括服务可用状态、请求流量、调用链、错误计数，结构化的日志、服务依赖关系可视化等内容，以便发现问题及时修复，实时调整系统负载，必要时进行服务降级，过载保护等等，从而让系统和环境提供高效高质量的服务。



### 自动化

在微服务架构下，面临如下挑战：

- 分布式系统
- 多服务，多实例
- 手动测试，部署，发布太消耗时间
- 反馈周期太长

传统的手工运维方式必然要被淘汰，微服务的实施是有一定的先决条件：那就是自动化，当服务规模化后需要更多`自动化`和`标准化`的手段来提升效能和降低成本。

- 自动化测试必不可少，因为对比单块系统，确保我们大量的服务正常工作是一个更复杂的过程。
- 调用一个统一的命令行，以相同的方式把系统部署到各个环境。
- 考虑使用环境定义来帮助你明确不同环境间的差异，但同时保持使用统一的方式进行部署的能力。
- 考虑创建自定义镜像来加快部署，并且拥抱全自动化创建不可变服务器的实践。

`自动化一切可以自动化的`，降低部署和发布的难度, 比如： 在持续集成和持续交付中，自动化编译，测试，安全扫描，打包，集成测试，部署，随着服务越来越多，在发布过程中，需要进一步自动化蓝绿部署（做到老版本到新版本的平滑过渡）还可以使用pipeline as code的实践，用代码来描述你的流水线。关于部署有很多选择，可以使用虚拟机，容器docker，或者流行的无服务架构lambda（AWS Lambda 也有一些明显的局限。它并不适合被用来部署长期运行的服务，请求需要在 300 秒内完成，当然你可以通过hack的方式延迟时间)。



## AKF拆分原则

![img](../../Image/2022/09/220928-1.jpg)

X 轴 ：指的是水平复制，很好理解，就是讲单体系统多运行几个实例，做个集群加负载均衡的模式。

Z 轴 ：是基于类似的数据分区，比如一个互联网打车应用突然或了，用户量激增，集群模式撑不住了，那就按照用户请求的地区进行数据分区，北京、上海、四川等多建几个集群。

Y 轴 ：就是我们所说的微服务的拆分模式，就是基于不同的业务拆分。



## 前后端分离

前后端技术分离，可以由各自的专家来对各自的领域进行优化，这样前端的用户体验优化效果会更好。

分离模式下，前后端交互界面更加清晰，就剩下了接口和模型，后端的接口简洁明了，更容易维护。

前端多渠道集成场景更容易实现，后端服务无需变更，采用统一的数据和模型，可以支撑前端的web UI\ 移动App等访问。



## 无状态服务

例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。








