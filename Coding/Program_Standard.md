# Table Of Contents
[TOC]

# 软件开发
## 软件的目的
软件存在的目的就是它能解决一些领域的相关问题，这是它存在的唯一理由。

## 软件设计的目标
在软件从0到1的过程，就是软件设计的作用范围。软件设计的目标就是：通过提升代码的可维护性来避免软件的失控。

## 失控的根本原因
### 错误理解的原因
- 业务太复杂

复杂性是业务本身存在的客观属性，是不会以人的意志来改变的，除非你不做它了。

业务本身具备的复杂性无法降低和消除，但是把业务转化为软件后的交互方式则是可以控制的，这也是软件设计的一部分。

- 项目遗留的代码太烂

项目遗留的代码太烂是失控的一种表现结果。

- 团队成员水平参差不齐

这是在推卸责任。

- 工期太紧张

即使再紧张也会要有基础的处理，而不会裸奔。

### 根本原因
现存的无力维护(bug、新功能都是维护)的代码导致的失控，同时这也是失控的表现结果。那么你为什么会无力维护这些代码，因为它的真实行为和你理解的行为出现了偏差，你觉得它不可控了。这时候就是真的失控了，代码烂不烂其实并不是重点，只要你还能维护，这些都不是问题。

## 项目失控场景
- 有个已知的bug，你改动的时候发现牵扯的东西太多了，牵一发而动全身，你不敢下手。你觉得代码无法控制了……
- 有个未知的bug，你找了好久找不到，代码太乱了。你觉得一股无力感……
- 有个新功能来了，你发现你要改这里那里，但是完全不知道改了会不会破坏现有的功能，也不知道新功能是不是真的可以work。你觉得你无法掌控这些代码了……
- 还有一些其他的情况，总之就是你觉得你无法掌控代码的真实行为了，你不知道你的代码会产生什么样的结果，就像薛定谔的代码一样……

## 软件可维护性
### 可理解性
客观上的可理解性。那么到底什么才能叫客观？没法度量啊！其实也不复杂，就是看当你读到一段代码的时候，你是否需要额外的思考，额外的脑中维持一个上下文的环境才能明白这段代码的意图，如果需要，那么就是不可理解的，至少也是不易理解的。更简单点说就是这段代码应该让你不用思考就看的明白它的意图。

### 可测试性
代码只会按照编写的行为去执行，而不是按照所想的行为去执行，通过测试确保代码真实的行为和所想的行为是一致的。

把所想的行为也写成代码，去验证业务代码执行的时候是不是会按照给定的输入得到期望的输出结果。借助自动化的CI，就可以在每次改动代码时把现有的所有测试都运行一遍。

然后你至少可以获得3点收益：
- 代码真的时按照你认为的行为去执行的。
- 确保你的改动不会破坏现有的代码行为。
- 倒逼你的代码进行合理的分解和抽象，不然你很难编写有效的测试。

当然你可能把测试写错了，，，这种概率就小多了吧。况且假设你真的写错了测试，时间久了，这个错误也就变成了feature。为什么呢？也许你代码的消费方已经按照它实际的行为去处理了，这时候你贸然把这个bug修复了，结果可能时消费方反而不能正常工作了。这时候这个错误的测试其实也就变成了消费方的一种契约测试。确保你不会把它改对，，，

### 可隔离性
可隔离性就是这样的一个备选方案，其意图就是隔离你的代码行为，哪怕它就是腐烂变质成了不可维护的代码，只要不影响其他的模块，那么就还算是可控的。就像万吨巨轮，底层的隔水舱总是一个个的独立的，一个进水了也不影响其他的，从而避免整体的失控。

## 参考资料
- [ ] []()
- [ ] [降低软件复杂性一般原则和方法](https://tech.meituan.com/2019/09/19/common-method-of-reduce-complexity.html)
- [x] [软件设计的目标和途径](https://www.cnblogs.com/linianhui/p/objective-and-approach-of-software-design.html)